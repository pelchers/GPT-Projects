# ðŸ’» Frontend Development Guide

This guide provides best practices and structural guidelines for building robust, performant, and maintainable frontend components and data-fetching strategies in your React + React-Query application.

---

## ðŸ“Œ React Component Structuring (Chat UI Patterns)

### âœ… Chat Component Hierarchy

Clearly structured chat components for maximum maintainability and scalability:

```
ChatPage (pages/chat.tsx)
â”‚
â”œâ”€â”€ Layout Component
â”‚   â”œâ”€â”€ Header Component (user profile, navigation)
â”‚   â”œâ”€â”€ Sidebar Component (project switcher, file listings)
â”‚   â””â”€â”€ Main Content Component
â”‚        â””â”€â”€ ChatWindow.tsx
â”‚             â”œâ”€â”€ MessageList.tsx
â”‚             â”‚   â”œâ”€â”€ MessageItem.tsx (individual messages, files)
â”‚             â”‚   â””â”€â”€ FilePreview.tsx (embedded file previews)
â”‚             â””â”€â”€ MessageInput.tsx (slash-command interface)
â”‚                  â””â”€â”€ ActionButtons.tsx (commands like /new-doc)
```

### âœ… Key Component Responsibilities

* **ChatWindow\.tsx:** Central orchestrator; manages state and data flow to subcomponents.
* **MessageList.tsx:** Efficient rendering of messages and handling scroll/load behavior.
* **MessageItem.tsx:** Atomic UI unit handling individual message content, states, and interactions.
* **MessageInput.tsx:** Captures input, handles slash commands, and interfaces with API hooks.
* **ActionButtons.tsx:** Provides intuitive, actionable UI elements tied to specific slash-commands.

### âœ… Best Practices

* **Atomic Design:** Structure components from small reusable atoms upwards.
* **Separation of Concerns:** Clearly isolate data fetching (via hooks), presentation logic, and user interactions.
* **Optimized Rendering:** Utilize `React.memo`, `useCallback`, and `useMemo`.
* **Error Boundaries & Validation:** Encapsulate components within error boundaries; validate inputs rigorously.

---

## ðŸ“Œ React-Query Caching Strategy Guide

React-Query significantly enhances performance and responsiveness through efficient caching.

### âœ… General Setup

Initialize your global React-Query client for consistent caching strategies:

```typescript
// queryClient.ts
import { QueryClient } from '@tanstack/react-query';

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: 1000 * 60 * 5, // 5 minutes
      cacheTime: 1000 * 60 * 30, // 30 minutes
      refetchOnWindowFocus: false,
    },
  },
});
```

---

### âœ… Data Fetching Patterns

Utilize custom hooks for clear separation and reuse:

```typescript
// useChatMessages.ts
import { useQuery } from '@tanstack/react-query';
import api from '../lib/api';

export function useChatMessages(chatId: string) {
  return useQuery(['chatMessages', chatId], () => api.getChatMessages(chatId), {
    enabled: !!chatId,
  });
}
```

---

### âœ… Cache Invalidation & Refetching

Explicitly invalidate caches after mutations:

```typescript
// useSendMessage.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import api from '../lib/api';

export function useSendMessage() {
  const queryClient = useQueryClient();
  
  return useMutation(api.sendMessage, {
    onSuccess: (data, variables) => {
      queryClient.invalidateQueries(['chatMessages', variables.chatId]);
    },
  });
}
```

---

### âœ… Best Practices for React-Query

* **Consistent Query Keys:** Clearly defined, structured query keys.
* **Optimized Cache Lifetimes:** Adjust based on data sensitivity.
* **Selective Refetching:** Avoid unnecessary refetches; fine-tune refetch options.
* **Error & Loading States:** Clearly handle loading/error states to improve UX.

---

## ðŸ“Š Recommended Next Steps

* Implement and test outlined React component patterns in your chat UI.
* Document and verify React-Query caching strategies through testing.
* Develop visual flow diagrams demonstrating React-Query state changes and component interactions.
